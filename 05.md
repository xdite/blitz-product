# 第五章 - 敏捷开发以及 User Story

之前我在刚变成程序员时，对于一个网路产品怎么样建构出来。我是完全一无所知的。

## 瀑布式开发

当时一般比较大的网路公司是这样做的。所以假设一个产品需要六个月，以下是最常出现的时间线：

* 花了 3 - 4 個月的訪談需求
* 花了 1 個月請美術設計視覺與介面，以及反覆修改
* 最後剩下不到 两周再請 RD 进场写程式。

这当中最痛苦的是每周的产品会议。PM 就会召集RD在会议室开会，然后与有一搭没搭的 "BrainStorming"。看看 PM 搜集到的需求，到底能不能做。

通常程序员会觉得参加这个会议很痛苦。因为老是会出现这样的冲突：

* PM 可能觉得很容易，RD 觉得被侮辱了
* PM 觉得理所当然的功能，RD 身为重度使用者一看就知道不可行
* RD 一直枪掉 PM 的功能，PM 觉得 RD 不尊重业务专业与创意

通常一个项目，了四五个月的时间，都花在这些会议上。确保产出「完备的规格」。才把这个需求收集好，再把这些规格交给视觉设计师设计介面。

设计师设计介面又需要几周，反覆跟 PM 确认介面流程没有播理解错误。最后当程序员开始实做时，只剩下两周时间。

这就是什么为什么多数的网络产品服务刚上线时网站都是破破烂烂的。一个项目所有的时间，都被花在策划跟画图。

程序员面对这样的状况是很崩溃的。程序员不是不想打造好产品，这么庞大的产品架构，却留给我们这么少的实做时间。但是死线已经被压紧紧了，不要说根本没有时间「写好」，光是「写完」都是奢望。

就算是是知道一些功能与特效没必要在第一版上线，刻意跳过或删掉。但是在跳掉过的过程，有时候也会不小心删掉「核心功能」，上线日见到一个破烂产品简直是必然的。

上线后一个月：

* 到处都是 Bug
* 内部策划团队抱怨
* 使用者抱怨

上线后第二个月：

* 终于写完当初规划的程式
* 终于修完大部分的 Bug
* 使用者早已认定这是个未完工的网站，不再来访

上线后第三个月：

* 因为网站规划不良，使用者对这个网站不感兴趣
* 因为网站规划不良，预计的成效没有出来
* 还有资源 => 继续筹画下六个月的改版
* 已无资源 => 死城

要知道没有人愿意看到这样的结局。身为产品创作者日夜加班，时间却老是浪费在这样的循环流程上。

然而这就是绝大多公司内部所谓的瀑布式开发。

## 敏捷式开发

参与了用瀑布式开发的两个产品后，我隐隐约约觉得这件事不太对劲？有没有办法可以加速这件事情？

一个项目真的是得收集完所有规格才能写吗？不能一边规划一边开发吗？

这时候一个新协作方式 敏捷 agile，映入眼帘。有别于瀑布式开发，敏捷强调适应真实需求的快速变化。

敏捷的流派有很多，这里举一些敏捷流派内常用的方法：

* Scrum 里面提到的 User Story，解决「规格被各自解读」的问题。
* Kanban 的 Story Board，是解决「时间就不知不觉被挥霍掉」的问题。
* Daily Standup 解决「大家都不沟通，结果执行方向歪掉」的问题。
* Integrate Early, Integrate Often 解决「最后一个月才开始看到成果，所有人包括金主看到最后成果都大愤怒」的问题。

etc....

我们在这里不深入细讲每个工作方法。这章主要的重点在介绍 User Story。

## 什么是 User Story？

瀑布式开发流程是 PM 花上很多的时间进行访谈写成规格，程序员再根据规格开发成功能。不过在这段过程中，却容易出现相当大的风险。

当中的问题出在于 PM 的「规格」有很大的机会天马行空，即使不天马行空，也有可能不贴近使用情境，或者是根本脱离真实使用情境。 RD 自然拿到规格和画面流程进行「转换」时，万分痛苦。

当然，更多时候， RD 根本不知道要怎么「转换」。这就是为什么每个专案都花了很多时间进行了需求访谈，也可能写了详细的规格，专案却始终容易出包，都是在「转换过程」中出现了问题。

网站其实是一堆人在上面用这个功能，所以我们应该要围绕着使用者会在上面用什么功能才对。

User Story 强调透过一份简单的情境规格，具体的描述出软体在「使用者」的手上，是怎么样被「操作」的。透过一个一个使用场景，整理出「角色」以及「会完成的工作与价值」。

而不是传统瀑布开发的方式，以「画面」为主体，钜细靡遗的标注画面里的细节，与特效。

举例来说，User Story 的范本如下：

> 作为一个 (某个角色) 使用者，我可以做 (某个功能) 事情，如此可以有 (某个商业价值) 的好处。

这里是一些 User Stories 的范例

> * 使用者可以在网站上张贴履历
> * 使用者可以搜寻有哪些工作
> * 公司可以张贴新工作
> * 使用者可以限制谁可以看到他的履历

就是这么简单。

有人可能会怀疑这样的规划「太过简陋」。其实不然，一个网站的实做价值与「主要功能」，其实大概 10-20 条之内就可以书写完毕了。

世界上所有产品都是活的。是不断演化的。但产品开发的最重要的结果是必须产出有价值的结果。

User Story 撰写是以角色作为划分：身为「什么角色」，我要「做什么事情」。

在瀑布式开发流程中，很多时后代码会写不完是因为「里面有隐藏的角色」，比如说

* 部落格后台应该「要有后台管理介面」。光是有「这个后台管理介面」，背后就隐藏著「一个后台管理员的角色」，加入这个角色所需要做的动作开发量几乎就是 2 倍！（因为后台管理员可以在后台管理编辑所有文章，几乎等于要重写类似文章发表编辑的功能，只是在另外一个「管理后台」）
* 又比如说网路电商网站「应该要有对帐号台」。背后就隐藏著「一个会计角色」，加入这个角色所需要的额外开发量几乎是难以估计。因为对帐需求真是千奇百怪。

绝大多数的瀑布式开发，都是被这种「隐藏式功能」搞爆工作量的。

而透过 User Story 方式，我们可以提早把

* 有多少人
* 有多少事

先大概抓出来。甚至把暂时把「不重要角色」要做的事先屏蔽掉。

而 User Story 的撰写过程中，与画面设计完全无关。我们可以透过这样的方式。先大致把第一版程式需要完成的 Story 罗列出来，估算出工时。再依工作量与优先权删减迭代。

哪些是在头几个礼拜就要先实做的，否则会阻挡后面开发。有哪些功能是可以在上线前再添加。甚至是上线后再做也不迟。而需要的功能，或者无法被实作的功能，将在一个一个循环之中，被舍弃。

用了这个方法之后，我后续参与项目的工时，几乎减少了 2/3。从六个月降到两个月。

## 如何撰写 User Story

### 第一版

（第一版的 User Story 可以不用很复杂）

* 使用者可以在网站上张贴广告卖币
* 使用者可以在网站上张贴广告买币
* 使用者可以在网站上看到广告下单买币
* 使用者可以在网站上看到广告下单卖币

### 第二版

（我们发现其实这两个流程是重复的，为了避免前期开发太过复杂，因此决定先做发广告卖币，下单买币）

* 身为一个商家，我要能够在后台上架卖币广告，并且设定上架贩卖
* 身为一个消费者，我要能够在前台看到广告，并且下单购买


（这时候明确引入角色）

### 第三版

（把隐藏的前期细节加入）

* 身为一个商家，我要能够在后台上架卖币广告，并且设定上架贩卖
  - 使用者必须要充值数字币进来，有足够的馀额，才能够上架广告
* 身为一个消费者，我要能够在前台看到广告，并且下单购买
  - 使用者必须经过身分认证，才能使用下单购买功能

### 第四版

（将隐藏的功能梳理出来，变成主要大功能）


* 身为一个商家，我要能够在后台上架卖币广告，并且设定上架贩卖
* 身为一个消费者，我要能够在前台看到广告，并且下单购买
* 身为一个使用者，必须在站上拥有数字货币钱包，进行充值 / 提币
* 身为一个使用者，必须经过身份验证功能，才能使用完整功能
* 身为一个使用者，为了确保资产安全，必须绑定联系方式

（这个时候，把主要的 Must Have 找出来）

### 第五版

（展开主要大功能，继续展开 Must Have 里面的细节）

* 身为一个商家，我要能够在后台上架卖币广告，并且设定上架贩卖
  - 身为一个卖家，可以在管理后台上架广告
  - 身为一个卖家，可以在发布广告时调整价格
  - 身为一个卖家，广告锚定的应该是全球 BTC 行情均价
  - 身为一个卖家，可以在买币者下单后，与卖家沟通进行交易
  - 身为一个卖家，可以在买币者付完钱打款后，释放数字货币给对方
  - 身为一个卖家，可以在买币者下单后，收到通知后，立即处理订单
* 身为一个消费者，我要能够在前台看到广告，并且下单购买
  - 身为一个消费者，可以在前台看到下单广告列表
  - 身为一个消费者，可以在前台看到广告内容详情
  - 身为一个消费者，可以在下单后，与卖家沟通进行交易
  - 身为一个消费者，下单之后，卖家数字币必须进行锁定，确保交易安全
* 身为一个使用者，必须在站上拥有数字货币钱包，进行充值 / 提币
  - 身为一个使用者，可以申请一个钱包 (BTC/ETH)
  - 身为一个使用者，申请钱包后，可以拿到一个数字钱包地址
    - 身为一个使用者，可以充值到钱包地址（6个确认后到帐）
  - 身为一个使用者，可以发起提币
* 身为一个使用者，必须经过身份验证功能，才能使用完整功能
  - 身为一个使用者，必须通过 email 验证
  - 身为一个使用者，必须通过 实名 验证（身份证）
  - 身为一个使用者，必须通过 进阶 验证（银行卡）
* 身为一个使用者，为了确保资产安全，必须绑定联系方式
  - 身为一个使用者，必须通过 email 验证
  - 身为一个使用者，必须绑定二步验证

## 动工的实际版本

一般来说。写到第五版。一个网站大制的大骨架就会出来。

* 大骨架在完稿时大概会是 20 条上下的主要框架
* 中骨架是在大骨架下继续展开的 Must Have 功能，展开后大概会有 100 条。
* 这 100 条里面有更小的细节，最后扩展会最终会达到大至上 1000 条左右的规模。

我们会在大骨架完稿后，先做一版流程图，确定业务逻辑方向不会被这些细节冲散。

![](https://i.imgur.com/FreVmX6.png)
![](https://i.imgur.com/iN3OsBu.png)
![](https://i.imgur.com/wimc4O6.png)

### 重构式开发

拿到主动线后，身为团队主程，在开发时，并不会优先实做各个画面的细节。而是会直接把每一个大的 User Story 的画面骨干，先扑成一个完整的 Workflow。然后团队再以"重构"的方式，去补完每个画面的细节。

发布广告(以OTCBTC为例)

![](https://imgur.com/93FIfGu.png)

广告列表(以OTCBTC为例)

![](https://imgur.com/eoLDrH2.png)

下单页面(以OTCBTC为例)

![](https://imgur.com/vTT3FIO.png)

订单内容(以OTCBTC为例)

![](https://imgur.com/vTT3FIO.png)


钱包的演变流程

![](https://imgur.com/a/p22Y0Zk.png)


## 创业点子如何排 User Story 优先级

接下來我會將 Key Result 再次區分，用 MosCow Method 排優先權。

MosCow Method 是把所有的需求照

Must have
Should have
Could have
Won't have
的方式區分。

MosCow Method 配合時間倒序的專案管理方式特別有效。如果是用正向順序進行專案管理，人們往往會將需求通通定義為「Must Have」。

而如果將 Key Result 鎖在在有限的時間內，反而會迫使人們去決定重要順序。所有人的精力只會 Focus 在 Must have 與 Should have。

團隊可以在很短的時間，不拖泥帶水的取得 MVP 與 small wins。這正是 Startup 最需要的戰果。

## OTCBTC 与 ICOINFO 的 User Story
